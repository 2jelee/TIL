# TIL - YYYY-MM-DD

Topic: (예: Heap / Graph / OS Process vs Thread / Dynamic Programming)

------------------------------------------------------------------------

## 1) 학습 목적 및 배경 (Why)

-   학습 계기:
-   등장 영역:
    -   [ ] 자료구조
    -   [ ] 알고리즘
    -   [ ] 코딩 테스트
    -   [ ] CS 이론
-   해결하려는 문제 유형:
-   실무 확장 가능성:

------------------------------------------------------------------------

## 2) 핵심 개념 정리 (What)

## \### 2.1 정의

### 2.2 등장 배경

-   왜 필요했는가?
-   기존 방식의 한계는?

## \### 2.3 핵심 원리

-
-

### 2.4 시간 복잡도

연산   시간 복잡도   근거
  ------ ------------- ------
삽입                 
삭제                 
탐색

#### Big-O 분석 근거

-   반복 구조:
-   재귀 깊이:
-   내부 동작 원리:

### 2.5 공간 복잡도

-   기본 저장 공간:
-   추가 메모리 사용:
-   재귀 스택 사용 여부:

------------------------------------------------------------------------

## 3) 내부 구조 및 동작 원리 (How)

### 3.1 구조 설명 (ASCII/도식)

예:

            10
           /  \
          5    20

### 3.2 동작 과정 (Step-by-step)

1.
2.
3.
4.

### 3.3 예시 입력/출력

입력:

출력:

------------------------------------------------------------------------

## 4) 구현 (Implementation)

### 4.1 Java 구현 (대용량 데이터 기준)

``` java
import java.io.*;
import java.util.*;

public class Main {

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder sb = new StringBuilder();

        // TODO: 입력 파싱

        // TODO: 로직 구현

        System.out.print(sb.toString());
    }
}
```

### 4.2 구현 전략

-   사용한 자료구조:
-   선택 이유:
-   시간 복잡도:
-   공간 복잡도:
-   입출력 최적화:
    -   BufferedReader 사용 여부:
    -   StringBuilder 사용 여부:
-   구현 디테일:
    -   재귀 사용 여부(깊이/스택 고려):
    -   반복 변환 여부:
    -   불필요한 객체 생성 제거:
    -   오버플로/범위 체크(long 필요 여부):

------------------------------------------------------------------------

## 5) 코딩 테스트 적용 분석

### 5.1 문제 정보

-   플랫폼:
-   문제 이름:
-   난이도:
-   유형(패턴):

### 5.2 접근 전략

-   처음 접근:
-   핵심 아이디어:
-   분기/예외 처리:
-   정답 조건 검증 방식:

### 5.3 실패/실수 기록

-   시간 초과 원인:
-   메모리 초과 원인:
-   로직 오류:
-   경계값 처리:

### 5.4 개선 과정

-   개선 전 복잡도:
-   개선 후 복잡도:
-   변경 포인트:

------------------------------------------------------------------------

## 6) 대용량 데이터 관점 분석

-   입력 최대 크기:
-   목표 시간 복잡도 추정:
    -   N \<= 1e5: O(N log N)
    -   N \<= 1e6: O(N)
    -   N \>= 1e7: 상수 최적화 필수
-   실제 병목 지점:
-   개선 아이디어:
    -   자료구조 교체:
    -   중복 연산 제거:
    -   캐시 친화적 접근:
    -   GC 부담 감소:

------------------------------------------------------------------------

## 7) CS 이론 연결

### 7.1 연결되는 CS 키워드

-   OS:
-   Network:
-   DB:
-   Memory/Runtime:

### 7.2 이론 포인트

-   중요한 정의:
-   트레이드오프:
-   흔한 오해:

### 7.3 면접 대비 Q&A

-   Q1:
    -   A:
-   Q2:
    -   A:

------------------------------------------------------------------------

## 8) 확장 및 심화

-   관련 알고리즘/자료구조:
-   변형 문제:
-   추가 학습 키워드:
-   실무 적용 아이디어:

------------------------------------------------------------------------

## 9) 오늘의 인사이트

-   한 줄 요약:
-   다음 복습 포인트:
-   다음 학습 계획:

------------------------------------------------------------------------

## 복습 체크리스트

-   [ ] 시간 복잡도 설명 가능
-   [ ] 공간 복잡도 설명 가능
-   [ ] 직접 구현 가능
-   [ ] 변형 문제 적용 가능
-   [ ] 면접에서 설명 가능
-   [ ] 대용량 병목 판단 가능