제목: 99클럽 코테 스터디 2일차 TIL + 오늘의 학습 키워드

---
### 1. 오늘의 학습 키워드
- 동적계획법

### 2. 공부한 내용 본인의 언어로 정리하기
✅ 동적 계획법(Bottom-Up 방식)  
- 한 번 계산한 값을 저장하고, 나중에 다시 사용해서 빠르게 해결하는 방법이다.
- 작은 문제부터 차근차근 해결하며 f(n) 값을 구하는 방법.
- 배열을 이용하여 f(1), f(2), f(3)을 초기화하고, f(n) = f(n-1) + f(n-3)의 점화식을 활용하여 f(n)까지 계산하면 된다. 
- 시간복잡도는 O(n)이므로 매우 효율적이다.

#### DP가 필요한 문제 특징 
1.	중복 계산이 많다 -> 같은 값을 계속 구해야 한다. 
2. 작은 문제의 결과를 활용해 큰 문제를 해결할 수 있다.

#### 동적 계획법 적용 방법
1. 문제를 작은 문제로 나눈다.
2. 한 번 계산한 값을 저장한다. (배열 활용)
3. 이전에 계산한 값을 재사용하여 빠르게 해결한다.

#### 동적 계획법
- 중복 계산을 방지하기 위해 한 번 계산한 값을 저장하고 재사용하는 방식.
- 이 방법에는 Top-Down(메모이제이션)과 Bottom-Up(반복문) 방식이 존재.

1. 메모이제이션 (Top-Down 방식)  
>> 필요할 때 계산하고, 결과를 저장하여 다시 사용한다.”
````
import java.util.*;

public class Main {
    static long[] memo = new long[100]; // 메모이제이션 배열

    public static long fib(int n) {
        if (n == 1 || n == 2) return 1;
        if (memo[n] != 0) return memo[n]; // 저장된 값이 있으면 사용
        return memo[n] = fib(n - 1) + fib(n - 2); // 계산 후 저장
    }

    public static void main(String[] args) {
        System.out.println(fib(50)); // 매우 빠르게 결과 출력!
    }
}
````
✅ 장점
- 중복 계산 제거 → 속도 증가 
- 재귀 사용 → 코드가 직관적  

✅ 단점 
- 스택(Stack) 메모리를 사용 → n이 너무 크면 Stack Overflow 발생 가능 
   
2. 반복문 (Bottom-Up 방식, 일반적인 DP)
>> “작은 값부터 차례로 계산하고, 배열에 저장해두고 사용한다.”
````
public class Main {
    public static void main(String[] args) {
        int n = 50;
        long[] dp = new long[n + 1]; // DP 배열
        dp[1] = dp[2] = 1; // 초기값

        for (int i = 3; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2]; // 점화식 적용
        }

        System.out.println(dp[n]); // 매우 빠르게 결과 출력!
    }
}
````
✅ 장점
- 반복문 사용 → 스택 오버플로우 방지
- 시간 복잡도 O(n) → 매우 빠름

✅ 단점
- 배열을 사용하여 추가적인 메모리 필요 (하지만 메모이제이션과 비슷한 수준)

### 3. 오늘의 회고
- 어떤 문제가 있었고, 나는 어떤 시도를 했는지
    - 동적계획법 알고리즘 학습
- 어떻게 해결했는지
    - 동적계획법 개념 학습
- 무엇을 새롭게 알았는지
    - "동적계획법"의 종류
- 내일 학습할 것은 무엇인지
    - 복습

----
필수 해시태그: #99클럽 #코딩테스트준비 #개발자취업 #항해99 #TIL
