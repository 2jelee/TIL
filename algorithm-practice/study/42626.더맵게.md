# 제목: 99클럽 코테 스터디 16일차 TIL + 오늘의 학습 키워드

PGS) 42626. 더맵게

#### 제출
```
import java.util.PriorityQueue;

class Solution {
    public int solution(int[] scoville, int K) {
        // 최소 힙(우선순위 큐) 생성
        PriorityQueue<Integer> heap = new PriorityQueue<>();

        // 모든 음식의 스코빌 지수를 힙에 추가
        for (int s : scoville) {
            heap.add(s);
        }

        int mixCount = 0;  // 섞는 횟수
        
        // 가장 작은 값이 K 이상이 될 때까지 반복
        while (heap.size() > 1 && heap.peek() < K) {
            int first = heap.poll();   // 가장 맵지 않은 음식
            int second = heap.poll();  // 두 번째로 맵지 않은 음식
            int newScoville = first + (second * 2);  // 새로운 음식의 스코빌 지수

            heap.add(newScoville);  // 새 음식 추가
            mixCount++;  // 섞는 횟수 증가
        }

        // 모든 음식이 K 이상인지 확인
        return (heap.peek() >= K) ? mixCount : -1;
    }
}

```
 
## 오늘의 학습 키워드
- 자료 구조
- Heap

## 공부한 내용 본인의 언어로 정리하기 
###### 힙   
- 최소 힙
  1. 가장 작은 값이 항상 맨 앞에 위치하는 자료구조  
  2. poll() or peek()을 사용하면 최솟값을 빠르게 찾을 수 있음  

  [최소 힙 선언 및 사용법]  
  ```
  import java.util.PriorityQueue;

public class MinHeapExample {
    public static void main(String[] args) {
        // 최소 힙 생성
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();

        // 값 추가
        minHeap.add(5);
        minHeap.add(1);
        minHeap.add(3);
        minHeap.add(7);
        minHeap.add(2);

        // 최소값 확인 (제거 X)
        System.out.println("최소값: " + minHeap.peek()); // 출력: 1

        // 최소값을 하나씩 꺼내면서 출력
        while (!minHeap.isEmpty()) {
            System.out.print(minHeap.poll() + " ");  // 출력: 1 2 3 5 7
        }
    }
}

  ```
  ✅ add(): 값을 추가하면 자동 정렬됨.
  ✅ peek(): 최소값을 확인 (제거 X).
  ✅ poll(): 최소값을 가져오면서 제거.
  
- 최대 힙
  - Java의 PriorityQueue는 기본적으로 최소 힙이므로 최대 힙을 만들려면 Comparator.reverseOrder()를 사용해야 함.
  ```
  import java.util.Collections;
  import java.util.PriorityQueue;
  
  public class MaxHeapExample {
      public static void main(String[] args) {
          // 최대 힙 생성
          PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());
  
          // 값 추가
          maxHeap.add(5);
          maxHeap.add(1);
          maxHeap.add(3);
          maxHeap.add(7);
          maxHeap.add(2);
  
          // 최대값 확인 (제거 X)
          System.out.println("최대값: " + maxHeap.peek()); // 출력: 7
  
          // 최대값을 하나씩 꺼내면서 출력
          while (!maxHeap.isEmpty()) {
              System.out.print(maxHeap.poll() + " ");  // 출력: 7 5 3 2 1
          }
      }
  }
  ```
  ✅ Collections.reverseOrder() 를 사용하면 최대 힙으로 동작.
  ✅ poll() 을 하면 가장 큰 값부터 출력됨.


[Stack의 pop() vs peek() ]  
pop(), peek()은 가장 위(top)에 있는 요소를 다루는 메서드이지만 중요 차이점이 존재.  
#### pop()
동작: 맨 위 요소를 가져옴  
반환값: 맨 위 요소  
스택에서 제거 여부: 제거O  
#### peek()
동작: 맨 위 요소를 확인함  
반환값: 맨 위 요소  
스택에서 제거 여부: 제거 X  



## 오늘의 회고
  ### 어떤 문제가 있었고, 나는 어떤 시도를 했는지
  ### 어떻게 해결했는지
  ### 무엇을 새롭게 알았는지 
  - pop()과 peek()의 차이
  #### 어떤 경우에 사용해야 할까?
	•	pop() → 값을 가져오면서 스택에서 제거해야 할 때 (예: 후위 표기법 계산기)  
	•	peek() → 현재 스택의 맨 위 값을 확인해야 할 때 (예: 연산 우선순위 검사)
   
 결론) 한마디로, pop()은 가져오면서 삭제하고, peek()은 확인만 한다!
  ### 내일 학습할 것은 무엇인지 
  - 지난 Hash 문제 복습 

  
----

필수 해시태그: #99클럽 #코딩테스트준비 #개발자취업 #항해99 #TIL
